<!DOCTYPE html>
<html>
	<head>
		<title>About This Book</title>
		<style>
			@media screen {
			  body {
					background-color: #f8dfb9;
				}	
			}
			nav {
				display: flex;
				flex-direction: row;
				justify-content: space-between;
			}
			nav > div {
				flex-grow: 0;
			}
			nav a {
				display: inline-block;
				padding: 0 0.5em 0.5ex;
			}
			nav a + a {
				border-left: 1px solid black;
			}
			nav a:hover {
				background: #0001;
			}
			article {
				margin: 0 16px;
			}
			article h1 {
				font-size: 200%;
			}
			figure {
				float: right;
				background: #eee;
				border: 1px solid #888;
				display: table;
				padding: 0 1em;
				text-align: center;
			}
			figure img {
				background: white;
				border: 1px solid #ccc;
				margin: 0;
			}
			figcaption {
				font-size: 14px;
				margin: 1em 0;
			}
			nav, hr, h1, h2, h3, h4, h5, h6 {
				clear: both;
			}
		</style>
	</head>
	<body>
		<nav>
			<div>
				<a href="../index.html">Home</a><a href="../index.html">Up</a><a href="../summaries/2.html" class="mdsite-prev-link">Prev</a>
			</div>
			<div>
				<a href="should-you-read.html" class="mdsite-next-link">Next</a>
			</div>
		</nav>
		<hr/>

		<article>
			<h1 id="about-this-book">About This Book</h1>
<p>At its best, software engineering is a joyful, social activity. It is also an intellectual activity, of course—but you already knew that.</p>
<p>My first purpose in writing this book is to show you that writing bug-free, efficient, maintainable software does <em>not</em> have to be a bureaucratic, soul-deadening exercise. To make really high-quality software, and do so sustainably, necessarily involves the most human (some would say the most &quot;childlike&quot;) parts of ourselves: enthusiasm, kindness, wonder, and even the possibility of grief.</p>
<p>My second purpose is to give you a map, a compass, and most importantly, confidence, as you set out to explore the vast and varied territory of our field. This book can&#39;t hope to cover everything, and it contains many pointers to other resources. But it will introduce you to many foundational concepts, and give you a framework on which to hang other ideas. And you&#39;ll need those other ideas: while there are many good ways to do things, there is no one &quot;right&quot; way, and we are all still very much in the process of figuring out how this &quot;software&quot; thing works. You&#39;ll be able to explain to your teammates why you make the technical choices you do. And you will gain—and this is perhaps the most important thing—you will gain a deep and abiding sense of connection to your work, and to the scientific and technological community out of which our discipline has grown.</p>
<p>My third purpose, related to the first two, is to give you &quot;eyes and hands&quot; to see and shape the software you work on. Reading this book will give you new ways of looking at your programs. Those &quot;views&quot; will give you insight into how your programs fit together at an architectural level, enabling you to identify and fix many potential problems before they impact production. This book will also equip you with a set of mental tools for shaping the systems you work on. That&#39;s &quot;tools&quot;, not &quot;rules&quot;: software-making is context-sensitive work, and requires constant adaptation. I&#39;m quite skeptical of simplistic &quot;best practices&quot;; rather, I prefer to cultivate a diverse set of skills and mental models, and use those to find the best way forward in each circumstance.</p>
<p>Unlike many other resources on software engineering, this book avoids moralizing. I reject the idea that buggy software, poor-quality code, etc. are due to programmers&#39; moral failings, immaturity, or stubbornness. I believe that most people want to do the right thing—though the rightest thing they know how to do may still be ineffective. I&#39;ve seen firsthand that even a team with the best of intentions, who want to do things &quot;the right way&quot;, can produce a bug-ridden mess that has to be thrown away after a year of development. I myself have made more messes than I care to count, in spite of my efforts to keep code clean and readable. But I&#39;ve also, at least once, <a href="https://github.com/gavmor/dunmanifestin/compare/3dd7afc9f582ad86e5f3828784a75375b81b56b2...431c1c2f7dbdfbe6833f6654ec4abdc6d8703212">gone back to my mess five years later and fixed it</a>. What changed in those five years? Not my motivation, nor my ideals. Only my skills. The problems in our industry are due to lack of skill, not lack of will—which I think is an optimistic take, because skills can be learned.</p>
<h2 id="buzzwords">Buzzwords</h2>
<p>&quot;Enough with the hifalutin&#39; ideals, BEN&quot; I hear you saying. &quot;I need a list of the buzzwords this book covers, so I can tell my boss why I&#39;m submitting an expense report for $0 to read an HTML page&quot;. Very well, I hear you.</p>
<p>In no particular order:</p>
<ul>
<li>Test-driven development</li>
<li>Evolutionary design</li>
<li>Refactoring</li>
<li>The Unix Philosophy</li>
<li>Type-driven design</li>
<li>Software quality</li>
<li>Software architecture</li>
<li>Agile software development</li>
<li>User interface design / visual design</li>
<li>User experience design</li>
<li>Philosophy</li>
</ul>
<h2 id="contents">Contents</h2>
<p>This prelude is followed by a collection of &quot;prolegomena&quot;, or &quot;first things to read&quot;. These contain important meta-information about how to interpret the rest of the book.</p>
<p>The rest of the book is divided into four parts:</p>
<ul>
<li><em><strong>Part I: Programming</strong></em> is about, well, programming—which in my book includes software design, testing, architecture, documentation—everything required to write bug-free, maintainable code on a budget. <em>Programming</em> is the first part of the book because it&#39;s the foundation of everything we do. Our job, ultimately, boils down to getting computers to do what we want in a way that doesn&#39;t cost a fortune. Although software design is, <a href="https://tidyfirst.substack.com/p/coming-soon">as Kent Beck points out</a>, an exercise in human relationships, relationships are founded on trust. Programmers earn trust by reliably delivering working software.</li>
<li><em><strong>Part II: Working With Others</strong></em> explores how to maintain and build human relationships around software once the initial level of trust is earned. It describes communication patterns and team dynamics that are good for the whole system—people <em>and</em> code, employees <em>and</em> customers.</li>
<li><em><strong>Part III: User Interfaces</strong></em> discusses the principles behind user interface design. There is a shortage of UI and UX designers in the software industry of 2023, and programmers are often called upon to make design decisions. This part of the book tries to ensure that the designs we produce will be comfortable and straightforward to use for the people who have to use them.</li>
<li><em><strong>Part IV: The Tao of Software Development</strong></em> goes back to the original software consultant&#39;s manual, the <em>Dào Dé Jīng</em>, or &quot;Book of the Way and Virtue&quot;, written 2500 years ago in China by an unknown author. While the details of software have changed much in the last two millennia, people have stayed approximately the same, so there is plenty of applicable wisdom in this venerable text. In this part of the book, we&#39;ll see that even the humblest aspects of programming contain profound insights into the nature of our universe and ourselves. The practical and the mystical will be fused, as if by lightning.</li>
</ul>
<h2 id="note-on-technologies">Note on Technologies</h2>
<p>With few exceptions, I avoid discussing specific technologies in this book. There are a couple reasons for that. One is that over-reliance on any specific technology (say, React, or Jest, or Ruby on Rails) would limit the audience for this book, which would be a shame because the book contains many concepts that apply across technologies. A second reason is that technologies evolve and get replaced, so books about them tend to go stale quickly. In writing, as in programming, I prefer to avoid dependencies on specific technologies, when I can.</p>
<p>The more fundamental reason is that learning any one technology just isn&#39;t that important for your overall career. A generalist programmer—someone who&#39;s familiar with the various shapes that tools can take—can become productive with a new library or framework in a matter of weeks.  Furthermore, your coworkers can almost certainly teach you the tech your company uses—and the specific <em>ways</em> they use that technology—with much higher fidelity than a book ever could.</p>
<p>The exception is &quot;foundational&quot; technologies, like Unix, <code>bash</code>, <code>git</code>, SQL databases, and (probably) your programming language of choice. It&#39;s worth spending the time to master these. They change slowly, so your knowledge will pay dividends for a long time, and they&#39;re so ubiquitous that it&#39;s hard to avoid depending on them. Additionally, the abstractions presented by these technologies tend to be &quot;leaky&quot;—details of the implementation rear their head from time to time—so having deep knowledge of how they work can help you avoid and escape their pitfalls. Finally, the widespread use of foundational technologies tends to make them rock-solid stable. Maintaining this stability demands a level of engineering rigor that is worth studying for its own sake. I point out many of these foundational technologies in the book, but I don&#39;t dive deep. Their documentation is easy enough to find.</p>
<p>There&#39;s no hard line between &quot;foundational&quot; and &quot;non-foundational&quot; technologies, though—it&#39;s a spectrum. Use your own judgement about what to spend time learning.</p>
<p>There&#39;s one technology dependency I couldn&#39;t avoid—the programming language I use for code examples. For that, I chose TypeScript. TypeScript is a superset of JavaScript that introduces a static type system. Because JavaScript is a multi-paradigm language that can run on both client and server, and because TypeScript enables but does not require static type safety, TypeScript is an ideal vehicle for comparing different approaches to programming. TypeScript also happens to be rapidly growing in popularity as of this writing—though it hasn&#39;t yet overtaken JavaScript, which has maintained its position as the most widely-used language (according to <a href="https://insights.stackoverflow.com/survey/2020#most-popular-technologies">polls of StackOverflow users</a>) for the last decade.</p>
<h2 id="about-the-author">About the Author</h2>
<p>I started programming in 1998. Since then, I&#39;ve worked on many different projects in a variety of languages, including JavaScript, TypeScript, Go, Ruby, Java, C, Bash, and Visual Basic. I have more than a decade of industry experience, and have worked professionally on over a dozen teams, building everything from point-of-sale systems to social networks and ed-tech apps. I&#39;ve also worked on many, many side projects, sometimes on my own, and sometimes with a friend. All told, I&#39;ve spent about 30,000 hours programming, and just about every hour has taught me something new.</p>
		</article>

		<hr/>
		<nav>
			<div>
				<a href="../index.html">Home</a><a href="../index.html">Up</a><a href="../summaries/2.html" class="mdsite-prev-link">Prev</a>
			</div>
			<div>
				<a href="should-you-read.html" class="mdsite-next-link">Next</a>
			</div>
		</nav>
		<script>
document.onkeydown = (e) => {
	switch (e.key) {
		case "ArrowRight":
		  document.querySelector(".mdsite-next-link")?.click()
			break;
		case "ArrowLeft":
			document.querySelector(".mdsite-prev-link")?.click()
			break;
	}
}

		</script>
	</body>
</html>
