<!DOCTYPE html>
<html>
	<head>
		<title>About This Book</title>
		<style>
			@media screen {
			  body {
					background-color: hsl(36, 83%, 85%);
				}	
			}
			nav {
				display: flex;
				flex-direction: row;
				justify-content: space-between;
			}
			nav > div {
				flex-grow: 0;
			}
			nav a {
				display: inline-block;
				padding: 0 0.5em 0.5ex;
			}
			nav a + a {
				border-left: 1px solid black;
			}
			nav a:hover {
				background: #0001;
			}
			article {
				margin: 0 16px;
			}
			article h1 {
				font-size: 200%;
			}
		</style>
	</head>
	<body>
		<nav>
			<div>
				<a href="../index.html">Home</a><a href="../index.html">Up</a><a href="../index.html" class="mdsite-prev-link">Prev</a>
			</div>
			<div>
				<a href="should-you-read.html" class="mdsite-next-link">Next</a>
			</div>
		</nav>
		<hr/>

		<article>
			<h1 id="about-this-book">About This Book</h1>
<p>Software engineering is a joyful, social activity. It is also an intellectual activity, of course—but you already knew that.</p>
<p>My first purpose in writing this book is to show you that writing bug-free, efficient, maintainable software does <em>not</em> have to be a bureaucratic, soul-deadening exercise. To make really high-quality software, and do so sustainably, necessarily involves the most human (some would say the most &quot;childlike&quot;) parts of ourselves: enthusiasm, kindness, wonder, and even grief.</p>
<p>My second purpose is to give you a map, a compass, and most importantly, confidence, as you set out to explore the vast and varied territory of our field. This book can&#39;t hope to cover everything, and it contains many pointers to other resources. But it will introduce you to many foundational concepts, and give you a framework on which to hang other ideas. And you&#39;ll need those other ideas: while there are many good ways to do things, there is no one &quot;right&quot; way, and we are all still very much in the process of figuring out how this &quot;software&quot; thing works. You&#39;ll be able to explain to your teammates why you make the technical choices you do. And you will gain—and this is perhaps the most important thing—you will gain a deep and abiding sense of connection to your work, and to the scientific and technological community out of which our discipline has grown.</p>
<p>My third purpose, related to the first two, is to give you &quot;eyes and hands&quot; to see and shape the software you work on. Reading this book will give you new ways of looking at your programs. Those &quot;views&quot; will give you insight into how your programs fit together at an architectural level, enabling you to identify and fix many potential problems before they impact production. This book will also equip you with a set of mental tools for shaping the systems you work on. That&#39;s &quot;tools&quot;, not &quot;rules&quot;: software-making is context-sensitive work, and requires constant adaptation. I&#39;m quite skeptical of simplistic &quot;best practices&quot;; rather, I prefer to cultivate a diverse set of skills and mental models, and use those to find the best way forward in each circumstance.</p>
<p>Unlike many other resources on software design, this book avoids moralizing. I reject the idea that buggy software, poor-quality code, etc. are due to programmers&#39; moral failings, immaturity, or stubbornness. I believe that most people want to do the right thing—though the rightest thing they know how to do may still be ineffective. I&#39;ve seen firsthand that even a team with the best of intentions can produce a bug-ridden mess that has to be thrown away after a year of development. I&#39;ve <em>been</em> the programmer who writes the bug-ridden mess. I&#39;ve also been the programmer who <a href="https://github.com/gavmor/dunmanifestin/compare/3dd7afc9f582ad86e5f3828784a75375b81b56b2...431c1c2f7dbdfbe6833f6654ec4abdc6d8703212">goes back to that mess five years later and fixes it</a>. The problems in our industry are due to lack of skill, not lack of will—which I think is an optimistic take, because skills can be learned.</p>
<h2 id="contents">Contents</h2>
<p>This book is divided into four parts.</p>
<ul>
<li><em><strong>Part I: Programming</strong></em> is about, well, programming—which in my book includes software design, testing, architecture, documentation—everything required to write bug-free, maintainable code on a budget. <em>Programming</em> is the first part of the book because it&#39;s the foundation of everything we do. Our job, ultimately, boils down to getting computers to do what we want in a way that doesn&#39;t cost a fortune. Although software design is, <a href="https://tidyfirst.substack.com/p/coming-soon">as Kent Beck points out</a>, an exercise in human relationships, relationships are founded on trust. Programmers earn their coworkers&#39; and clients&#39; trust by quickly and reliably delivering working software.</li>
<li><em><strong>Part II: Working With Others</strong></em> explores how to maintain and build human relationships around software once the initial level of trust is earned. It describes communication patterns and team dynamics that are good for the whole system—people <em>and</em> code, employees <em>and</em> customers.</li>
<li><em><strong>Part III: User Interfaces</strong></em> discusses the principles behind user interface design. There is a shortage of UI and UX designers in the software industry of 2023, and programmers are often called upon to make design decisions. This part of the book tries to ensure that the designs we produce will be comfortable and straightforward to use for the people who have to use them.</li>
<li><em><strong>Part IV: The Tao of Software Development</strong></em> goes back to the original software consultant&#39;s manual, the <em>Dào Dé Jīng</em>, or &quot;Book of the Way and Virtue&quot;, written 2500 years ago in China by an unknown author. While the details of software have changed much in the last two millennia, people have stayed approximately the same, so there is plenty of applicable wisdom in this venerable text. In this part of the book, we&#39;ll see that even the humblest aspects of programming contain profound insights into the nature of our universe and ourselves. The practical and the mystical will be fused, as if by lightning.</li>
</ul>
<h2 id="note-on-technologies">Note on Technologies</h2>
<p>With few exceptions, I avoid discussing specific technologies in this book. There are a couple reasons for that. One is that over-reliance on any specific technology (say, React, or Jest, or Ruby on Rails) would limit the audience for this book, which would be a shame because the book contains many concepts that apply across technologies. A second reason is that technologies evolve and get replaced, so books about them tend to go stale quickly. In writing, as in programming, I prefer to avoid dependencies on specific technologies, when I can.</p>
<p>But there is a more fundamental reason for avoiding discussion of specific technologies: they just aren&#39;t that important for your overall career. A generalist programmer—someone who&#39;s familiar with the various shapes languages and tools can take—can become productive in a new language or framework in a matter of weeks.  Furthermore, your coworkers can almost certainly teach you the tech your company uses—and the specific <em>ways</em> they use that technology—with much higher fidelity than a book ever could.</p>
<p>The exception is &quot;foundational&quot; technologies, like Unix, <code>git</code>, SQL databases, and (probably) your programming language of choice. It&#39;s worth spending the time to master these. They change slowly, so your knowledge will pay dividends for a long time, and in any case they&#39;re so ubiquitous that it&#39;s hard to avoid depending on them. Since foundational technologies are widely used, they tend to be rock-solid stable. Maintaining this stability demands a level of engineering rigor that is worth studying for its own sake. I point out many of these foundational technologies in the book, but I don&#39;t dive deep. Their documentation is easy enough to find.</p>
<p>There&#39;s one technology dependency I couldn&#39;t avoid—the programming language I use for code examples. For that, I chose TypeScript. TypeScript is a superset of JavaScript that introduces a static type system. Because JavaScript is a multi-paradigm language that can run on both client and server, and because TypeScript enables but does not require static type safety, TypeScript is an ideal vehicle for comparing different approaches to programming. TypeScript also happens to be rapidly growing in popularity as of this writing—though it hasn&#39;t yet overtaken JavaScript, which has maintained its position as the most widely-used language (according to <a href="https://insights.stackoverflow.com/survey/2020#most-popular-technologies">polls of StackOverflow users</a>) for the last decade.</p>
<h2 id="about-the-author">About the Author</h2>
<p>I started programming in 1998. Since then, I&#39;ve worked on many different projects in a variety of languages, including JavaScript, TypeScript, Go, Ruby, Java, C, Bash, and Visual Basic. I have more than a decade of industry experience, and have worked professionally on over a dozen teams, building everything from point-of-sale systems to social networks and ed-tech apps. I&#39;ve also worked on many, many side projects, sometimes on my own, and sometimes with a friend. All told, I&#39;ve spent about 30,000 hours programming, and just about every hour has taught me something new.</p>
		</article>

		<hr/>
		<nav>
			<div>
				<a href="../index.html">Home</a><a href="../index.html">Up</a><a href="../index.html" class="mdsite-prev-link">Prev</a>
			</div>
			<div>
				<a href="should-you-read.html" class="mdsite-next-link">Next</a>
			</div>
		</nav>
		<script>
document.onkeydown = (e) => {
	switch (e.key) {
		case "ArrowRight":
		  document.querySelector(".mdsite-next-link")?.click()
			break;
		case "ArrowLeft":
			document.querySelector(".mdsite-prev-link")?.click()
			break;
	}
}

		</script>
	</body>
</html>
