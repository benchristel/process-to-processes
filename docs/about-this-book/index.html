<!DOCTYPE html>
<html>
	<head>
		<title>About This Book</title>
		<style>
			@media screen {
			  body {
					background-color: #f8dfb9;
				}	
			}
			nav {
				display: flex;
				flex-direction: row;
				justify-content: space-between;
			}
			nav > div {
				flex-grow: 0;
			}
			nav a {
				display: inline-block;
				padding: 0 0.5em 0.5ex;
			}
			nav a + a {
				border-left: 1px solid black;
			}
			nav a:hover {
				background: #0001;
			}
			article {
				margin: 0 16px;
			}
			article h1 {
				font-size: 200%;
			}
			figure {
				float: right;
				background: #eee;
				border: 1px solid #888;
				display: table;
				padding: 0 1em;
				text-align: center;
			}
			img {
				display: block;
				background: white;
				border: 1px solid #ccc;
				margin: 0 auto;
			}
			figcaption {
				font-size: 14px;
				margin: 1em 0;
			}
			nav, hr, h1, h2, h3, h4, h5, h6 {
				clear: both;
			}
		</style>
	</head>
	<body>
		<nav>
			<div>
				<a href="../index.html">Home</a><a href="../index.html">Up</a><a href="../summaries/256.html" class="mdsite-prev-link">Prev</a>
			</div>
			<div>
				<a href="should-you-read.html" class="mdsite-next-link">Next</a>
			</div>
		</nav>
		<hr/>

		<article>
			<h1 id="about-this-book">About This Book</h1>
<p>Working on well-made software is both a fascinating intellectual puzzle and a joyful, social activity. Working on poorly-made software feels bewildering, frustrating, and alienating. Good software makes its users and programmers feel confident and competent. Bad software gaslights the people who interact with it, making them feel like they&#39;re stupid or losing their minds.</p>
<p>What makes some software good and other software bad? This book seeks to explore that question. Along the way, we&#39;ll distill some practical principles that you can use to make any software project better—no matter its current state.</p>
<h2 id="the-life-of-software-development-systems">The Life of Software development Systems</h2>
<p>Software development occurs within a complex system of many interacting sub-structures. These sub-structures include companies, office buildings, departments, teams, computers, people, business processes, services, code modules, and many other types of structure.
The software development system has a kind of life of its own: it comes into being, grows, persists for a time, and eventually &quot;dies&quot; or disappears. While the system lives, it can be &quot;healthy&quot; or &quot;unhealthy&quot;. Most of us have worked in unhealthy software development systems at some point in our careers. We know how these systems feel from the inside: there is disorder, miscommunication, blame, panic, firefighting. People distrust and micromanage each other. Projects get roadblocked; some teams are overloaded with work while others are stuck waiting for them with nothing to do. The code is usually an unintelligible, buggy nightmare.</p>
<p>A lucky few, though, have worked in very healthy systems and have seen firsthand the excellent work that these systems can produce. My thesis, which I explore in detail in this book, is that <strong>only a healthy system is capable of producing good software. If we want to make good software, we first need to create a healthy system.</strong></p>
<p>In my own career, I have been very lucky to work in some of the healthiest systems in the software industry. I&#39;ve seen firsthand what software development looks like when it is working well. I&#39;ve also had my share of failures, and have learned at least as much from those as I did from the successes.</p>
<h2 id="the-role-of-individuals">The Role of Individuals</h2>
<p>If the quality of our software depends to such a great extent on the health of the whole development system, can individual programmers do anything to improve the software? I think they certainly can.</p>
<p>In a healthy system, programmers have a certain degree of autonomy. Managers set a direction and a budget, listen to the programmers&#39; feedback about what will fit within the budget, and then let the programmers loose and trust them to do their best work. The key word there is &quot;trust&quot;. Programmers and managers have to trust each other. In order for trust to be genuine, it must be earned. The way that programmers earn trust is by reliably delivering high-quality work within a budget. Doing that, and balancing all the human and technical factors in play, takes a great deal of skill and expertise.<!--A system where trust is given but not earned will be weakened, as managers learn to accept sub-par quality and programmers never get feedback about which skills they could improve.--></p>
<p>So, the health of the system rests on trust, and trust rests on programmers&#39; expertise. In order for the system to be truly healthy, we, the programmers, must be experts. We have to continuously improve our skills and practices. That&#39;s where this book comes in.</p>
<p>Some other resources on software engineering seem to assume that buggy software, poor-quality code, etc. are due to programmers&#39; moral failings: their immaturity, laziness, or resistance to change. This idea I wholeheartedly reject. I believe that most people want to do their best work and to do the right thing—though the rightest thing they know how to do may still be ineffective.</p>
<p>One of my own experiences may be instructive here. In 2015, the consultancy I was working for took on a project for a Fortune Global 50 company based in Germany. The project had many challenges, both social and technical, but the thing that ultimately killed it was the quality of our code. After working on the product (a phone app) for almost a year, we handed it off to the client. Unfortunately, the programmers at the client company found they couldn&#39;t understand or improve our code, and they ended up throwing all of it away and rewriting it.</p>
<p>I had the opportunity to work briefly with a few of the client&#39;s programmers during the handoff, and I learned two relevant facts about them:</p>
<ul>
<li>They were paid about a quarter of what I was. They said that a typical salary for a programmer in Germany at that time was 30,000 euros per year.</li>
<li>They were much better at programming than I was. Their code had a straightforward lucidity that I&#39;ve only encountered a few times in my career.</li>
</ul>
<p>I should clarify that the consultancy I worked for prided itself on its ability to produce high-quality code that our clients would be able to carry forward. We saw ourselves as the cutting edge of software development. Individually, we all cared deeply about our craft and tried to continuously improve it through practices like pair programming and retrospectives. To suddenly encounter <em>actually</em> good code, in the work of these German engineers who were paid like menial laborers, was a humbling wake-up call. I knew I had to up my game.</p>
<p>Unfortunately, the wake-up call came too late. Our contract with the German client ended on (understandably) lukewarm terms. We failed to close the next and only lead in our pipeline, and a few months later our office was disbanded. (Amazingly—and I don&#39;t know if this was charity or business savviness—no one got laid off. We all had the opportunity to move to other, internal projects.)</p>
<p>I am an optimist. I believe that we all, deep down, want to do our best work. We all want our work to create joy and not create suffering. The problems in our industry are due to lack of skill, not lack of will—which I think is an optimistic take, because skills can be learned.</p>
<h2 id="buzzwords">Buzzwords</h2>
<p>&quot;Enough with the hifalutin&#39; ideals, BEN&quot; I hear you saying. &quot;I need a list of the buzzwords this book covers, so I can tell my boss why I&#39;m submitting an expense report for $0 to read an HTML page&quot;. Very well, I hear you.</p>
<p>In no particular order:</p>
<ul>
<li>Test-driven development</li>
<li>Evolutionary design</li>
<li>Refactoring</li>
<li>The Unix Philosophy</li>
<li>Type-driven design</li>
<li>Software quality</li>
<li>Software architecture</li>
<li>Agile software development</li>
<li>User interface design / visual design</li>
<li>User experience design</li>
<li>Philosophy</li>
</ul>
<h2 id="contents">Contents</h2>
<p>This prelude is followed by a collection of &quot;prolegomena&quot;, or &quot;first things to read&quot;. These contain important meta-information about how to interpret the rest of the book.</p>
<p>The rest of the book is divided into four parts:</p>
<ul>
<li><em><strong>Part I: Programming</strong></em> is about, well, programming—which in my book includes software design, testing, architecture, documentation—everything required to write bug-free, maintainable code on a budget. <em>Programming</em> is the first part of the book because it&#39;s the foundation of everything we do. Our job, ultimately, boils down to getting computers to do what we want in a way that doesn&#39;t cost a fortune. Although software design is, <a href="https://tidyfirst.substack.com/p/coming-soon">as Kent Beck points out</a>, an exercise in human relationships, relationships are founded on trust. Programmers earn trust by reliably delivering working software.</li>
<li><em><strong>Part II: Working With Others</strong></em> explores how to maintain and build human relationships around software once the initial level of trust is earned. It describes communication patterns and team dynamics that are good for the whole system—people <em>and</em> code, employees <em>and</em> customers.</li>
<li><em><strong>Part III: User Interfaces</strong></em> discusses the principles behind user interface design. There is a shortage of UI and UX designers in the software industry of 2023, and programmers are often called upon to make design decisions. This part of the book tries to ensure that the designs we produce will be comfortable and straightforward to use for the people who have to use them.</li>
<li><em><strong>Part IV: The Tao of Software Development</strong></em> goes back to the original software consultant&#39;s manual, the <em>Dào Dé Jīng</em>, or &quot;Book of the Way and Virtue&quot;, written 2500 years ago in China by an unknown author. While the details of software have changed much in the last two millennia, people have stayed approximately the same, so there is plenty of applicable wisdom in this venerable text. In this part of the book, we&#39;ll see that even the humblest aspects of programming contain profound insights into the nature of our universe and ourselves. The practical and the mystical will be fused, as if by lightning.</li>
</ul>
<h2 id="note-on-technologies">Note on Technologies</h2>
<p>With few exceptions, I avoid discussing specific technologies in this book. There are a couple reasons for that. One is that over-reliance on any specific technology (say, React, or Jest, or Ruby on Rails) would limit the audience for this book, which would be a shame because the book contains many concepts that apply across technologies. A second reason is that technologies evolve and get replaced, so books about them tend to go stale quickly. In writing, as in programming, I prefer to avoid dependencies on specific technologies, when I can.</p>
<p>The more fundamental reason is that learning any one technology just isn&#39;t that important for your overall career. A generalist programmer—someone who&#39;s familiar with the various shapes that tools can take—can become productive with a new library or framework in a matter of weeks.  Furthermore, your coworkers can almost certainly teach you the tech your company uses—and the specific <em>ways</em> they use that technology—with much higher fidelity than a book ever could.</p>
<p>The exception is &quot;foundational&quot; technologies, like Unix, <code>bash</code>, <code>git</code>, SQL databases, and (probably) your programming language of choice. It&#39;s worth spending the time to master these. They change slowly, so your knowledge will pay dividends for a long time, and they&#39;re so ubiquitous that it&#39;s hard to avoid depending on them. Additionally, the abstractions presented by these technologies tend to be &quot;leaky&quot;—details of the implementation rear their head from time to time—so having deep knowledge of how they work can help you avoid and escape their pitfalls. Finally, the widespread use of foundational technologies tends to make them rock-solid stable. Maintaining this stability demands a level of engineering rigor that is worth studying for its own sake. I point out many of these foundational technologies in the book, but I don&#39;t dive deep. Their documentation is easy enough to find.</p>
<p>There&#39;s no hard line between &quot;foundational&quot; and &quot;non-foundational&quot; technologies, though—it&#39;s a spectrum. Use your own judgement about what to spend time learning.</p>
<p>There&#39;s one technology dependency I couldn&#39;t avoid—the programming language I use for code examples. For that, I chose TypeScript. TypeScript is a superset of JavaScript that introduces a static type system. Because JavaScript is a multi-paradigm language that can run on both client and server, and because TypeScript enables but does not require static type safety, TypeScript is an ideal vehicle for comparing different approaches to programming. TypeScript also happens to be rapidly growing in popularity as of this writing—though it hasn&#39;t yet overtaken JavaScript, which has maintained its position as the most widely-used language (according to <a href="https://insights.stackoverflow.com/survey/2020#most-popular-technologies">polls of StackOverflow users</a>) for the last decade.</p>
<h2 id="about-the-author">About the Author</h2>
<p>I started programming in 1998. Since then, I&#39;ve worked on many different projects in a variety of languages, including JavaScript, TypeScript, Go, Ruby, Java, Scala, C, Bash, and Visual Basic. I have more than a decade of industry experience, and have worked professionally on over a dozen teams, building everything from point-of-sale systems to social networks and ed-tech apps. I&#39;ve also worked on many, many side projects, sometimes on my own, and sometimes with a friend. All told, I&#39;ve spent about 30,000 hours programming, and just about every hour has taught me something new.</p>
		</article>

		<hr/>
		<nav>
			<div>
				<a href="../index.html">Home</a><a href="../index.html">Up</a><a href="../summaries/256.html" class="mdsite-prev-link">Prev</a>
			</div>
			<div>
				<a href="should-you-read.html" class="mdsite-next-link">Next</a>
			</div>
		</nav>
		<script>
document.onkeydown = (e) => {
	switch (e.key) {
		case "ArrowRight":
		  document.querySelector(".mdsite-next-link")?.click()
			break;
		case "ArrowLeft":
			document.querySelector(".mdsite-prev-link")?.click()
			break;
	}
}

		</script>
	</body>
</html>
