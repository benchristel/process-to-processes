<!DOCTYPE html>
<html>
	<head>
		<title>What is a Process?</title>
		<style>
			@media screen {
			  body {
					background-color: #f8dfb9;
				}	
			}
			nav {
				display: flex;
				flex-direction: row;
				justify-content: space-between;
			}
			nav > div {
				flex-grow: 0;
			}
			nav a {
				display: inline-block;
				padding: 0 0.5em 0.5ex;
			}
			nav a + a {
				border-left: 1px solid black;
			}
			nav a:hover {
				background: #0001;
			}
			article {
				margin: 0 16px;
			}
			article h1 {
				font-size: 200%;
			}
			figure {
				float: right;
				background: #eee;
				border: 1px solid #888;
				display: table;
				padding: 0 1em;
				text-align: center;
			}
			img {
				display: block;
				background: white;
				border: 1px solid #ccc;
				margin: 0 auto;
			}
			figcaption {
				font-size: 14px;
				margin: 1em 0;
			}
			nav, hr, h1, h2, h3, h4, h5, h6 {
				clear: both;
			}
		</style>
	</head>
	<body>
		<nav>
			<div>
				<a href="../../index.html">Home</a><a href="index.html">Up</a><a href="values.html" class="mdsite-prev-link">Prev</a>
			</div>
			<div>
				<a href="effects.html" class="mdsite-next-link">Next</a>
			</div>
		</nav>
		<hr/>

		<article>
			<h1 id="what-is-a-process">What is a Process?</h1>
<p>In this book, I use the word <em>process</em> to mean &quot;a sequence of changes to some part of the world&quot;. We&#39;ll call the part of the world that a process changes the <em>state</em> of the process. Each change, or <em>step</em>, enacted by a process takes the current state and transforms it—often just a tiny bit—to get to the next state in the sequence. Though each change may be small, a long sequence of such changes can produce intricate structures or perform complex calculations.</p>
<p>Processes are interesting and useful because they give us a way to carry out very complex tasks with limited computational or mental resources. The machinery that performs each step tends to be restricted in some dimension: perhaps it has limited built-in memory, or a limited amount of time to perform each step. Perhaps the machinery is divided up into many parts that each act on a corresponding part of the state, and can only communicate with each other in limited ways. By recording information in the state for later use, the machinery is enabled to do its job.</p>
<p>Processes are everywhere. One everyday example of a process is pen and paper arithmetic. Most of us don&#39;t have the mental machinery to be able to multiply two ten-digit numbers in our heads, but by writing down the problem and performing a series of mechanical <em>steps</em> on that written <em>state</em>, we can reliably solve such problems.</p>
<p>Another example of a process is baking bread. When kneading dough, in particular, there is feedback from the dough to the baker; the process of kneading cannot be done insensitively if you want the result to be good. You need to assess the texture of the dough at every step, and continue adding flour just until the texture is right.</p>
<p>In both of these examples, note the key fact that the current state of the process informs the next step. This idea—that the state feeds back into the development of the process—is common to all processes.</p>
<h2 id="software-processes">Software Processes</h2>
<p>A software process is the running instantiation of a program. Programs are static data: bytes of code written to a file. Processes, by contrast, are dynamic, mercurial; real and yet intangible. In the same way that sheet music comes to life when an orchestra performs it, a program comes to life by directing the movements of a process.</p>
<pre><code>   program     : computer  : process
:: sheet music : orchestra : concert
</code></pre>
<p>On a macOS or Linux system, you can list the currently running processes by running <code>ps aux</code> at a terminal. A new process is created every time you run a program. For example, if you run <code>node</code> to start a JavaScript REPL, that creates a process. A single program can give rise to multiple concurrent processes. For example, if you open multiple terminal windows, you can run <code>node</code> in each one. The program <code>node</code> is unaffected by this; it remains, unchanging, on disk. The several <em>processes</em> instantiated from the program are identified (by the operating system) by different process IDs (PIDs), each associated with an independent <em>state</em>. The operating system arranges things so that each process&#39;s state evolves according to the rules of its program. (Note: this model of how processes work is extremely simplified, but it is adequate for the purposes of writing JavaScript.)</p>
<p>The preceding paragraph describes what I&#39;ll call <em>operating system processes</em>, but the abstract idea of a <em>software process</em> is more general. OS processes are <em>Turing complete</em>, so an OS process can simulate any number of other processes—it can even simulate a whole operating system! We can think of <code>node</code> as being just such a process simulator. <code>node</code> processes can perform any number of tasks, from serving web requests to compiling TypeScript, by reading in the source code of a JavaScript program and then &quot;simulating&quot; the evolution of a process instantiated from that program. I put &quot;simulating&quot; in quotes because these &quot;simulated&quot; processes can do quite real and useful work!</p>
<p>We can go one level further, and create our own simulated processes within a JavaScript process. The mechanism JavaScript provides for this is <em>generator functions</em>. Here is an example of a generator function:</p>
<pre><code class="language-js">function *greetForever() {
  let n = 0
  while (true) {
    console.log(&quot;Hello, world &quot; + n + &quot;!&quot;)
    n++
    yield
  }
}
</code></pre>
<p>The <code>*</code> before the function name makes <code>greetForever</code> a generator function. If we call <code>greetForever</code>, it does not enter an infinite loop, but simply returns a process-like object that JavaScript calls a <code>Generator</code>.</p>
<pre><code class="language-js">const process = greetForever()
</code></pre>
<p>How do we actually run this process? We can call the <code>next()</code> method on it:</p>
<pre><code class="language-js">process.next()
</code></pre>
<p>This causes the generator function to run until execution reaches a <code>yield</code> statement. Once a <code>yield</code> statement is reached, the process pauses execution, and the call to <code>next()</code> returns.</p>
<p>The visible effect of calling <code>process.next()</code> is that it logs <code>Hello, world 0!</code>. Internally, it also increments the <code>n</code> variable (part of the process&#39;s <em>state</em>). If we call <code>next()</code> again, it will log <code>Hello, world 1!</code>, and so on.</p>
<p>There is more to learn about generator functions in JavaScript, but it can wait for future chapters.</p>
<h2 id="deterministic-processes">Deterministic Processes</h2>
<h2 id="process-to-processes">Process to Processes</h2>
<p>The title of this book, <em>Process to Processes</em>, refers to the twin facts that 1) all software is developed by some kind of <em>process</em>, and 2) the ultimate result of software development is a set of running <em>processes</em> on one or more computers. Processes are the beginning and the end of software development, and they often show up in the middle, too. I will refer to the first type of process as a <em>development process</em>, and to the second type of process as a <em>software process</em>.</p>
<!--
But what exactly *is* a process? We have an intuitive notion of what a *development process* is, abstracted from examples like Scrum, Extreme Programming, and Waterfall. A development process tells you what steps to follow to make software. We also use the word "process" to mean the running instantiation of a _program_. We can list the running *processes* on a macOS or Linux computer using the `ps aux` command. Is there some notion of a process that is general enough to cover both of these senses of the word? I think there is.

## Definition of "Process"

A process is a sequence of _states_, defined by an initial state, S<sub>0</sub>, and an _algorithm_ that obtains the (n+1)<sup>th</sup> state, S<sub>n+1</sub>, from the n<sup>th</sup> state, S<sub>n</sub>. You can think of each state as a bundle of information—or, if you like, as a data structure. The sequence of states in a process is potentially infinite.

Let's first look at how this definition applies to software processes. Suppose we have the following JavaScript program:

```js
let i = 1;
while (i < 10) {
  i++;
}
```

There is one variable in this program, `i`, so we can model the state of the process it generates as a data structure holding a number and some indication of which line of the program will be executed next. Something like this (TypeScript):

```ts
type State = {i?: number, nextLine: number}
```

When our program starts running, the initial state is (conceptually):

```js
state = {i: undefined, nextLine: 1}
```

The first line of the program sets `i` to `1`. After that line executes, our state is:

```js
state = {i: 1, nextLine: 2}
```

The second line of the program checks whether `i` is less than `10`, continuing at line 3 if so and at line 4 if not. In this case, `i` *is* less than `10`, so we go to line 3. The next state is:

```js
state = {i: 1, nextLine: 3}
```

Line 3 increments `i` and loops back to line 2.

```js
state = {i: 2, nextLine: 2}
```

On line 2, we perform the check again; `i` is still less than 10, so we go back to line 3.

```js
state = {i: 2, nextLine: 3}
```

The state keeps evolving as we go around and around the loop. Eventually, `i` reaches 10. Here's what the state looks like immediately after `i` is incremented to 10 on line 3:

```js
state = {i: 10, nextLine: 2}
```

Back on line 2, the `i < 10` comparison evaluates to `false`. We go to line 4.

```js
state = {i: 10, nextLine: 4}
```

Line 4 is the end of the program, so each subsequent state in the process will be the same as the current one. Our process has *halted*.

This precise definition of a process isn't a perfect fit for either *software processes* or *software development processes*, though the nature of the misfit is different in each case.

The definition doesn't perfectly apply to software processes because the state of a software process can be changed by an intervention from outside the process (e.g. an _interrupt_, or the result of a _system call_). So the process's algorithm doesn't fully determine the sequence of states.

-->
		</article>

		<hr/>
		<nav>
			<div>
				<a href="../../index.html">Home</a><a href="index.html">Up</a><a href="values.html" class="mdsite-prev-link">Prev</a>
			</div>
			<div>
				<a href="effects.html" class="mdsite-next-link">Next</a>
			</div>
		</nav>
		<script>
document.onkeydown = (e) => {
	switch (e.key) {
		case "ArrowRight":
		  document.querySelector(".mdsite-next-link")?.click()
			break;
		case "ArrowLeft":
			document.querySelector(".mdsite-prev-link")?.click()
			break;
	}
}

		</script>
	</body>
</html>
