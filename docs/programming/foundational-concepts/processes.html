<!DOCTYPE html>
<html>
	<head>
		<title>What is a Process?</title>
		<style>
			@media screen {
			  body {
					background-color: #f8dfb9;
				}	
			}
			nav {
				display: flex;
				flex-direction: row;
				justify-content: space-between;
			}
			nav > div {
				flex-grow: 0;
			}
			nav a {
				display: inline-block;
				padding: 0 0.5em 0.5ex;
			}
			nav a + a {
				border-left: 1px solid black;
			}
			nav a:hover {
				background: #0001;
			}
			article {
				margin: 0 16px;
			}
			article h1 {
				font-size: 200%;
			}
			figure {
				float: right;
				background: #eee;
				border: 1px solid #888;
				display: table;
				padding: 0 1em;
				text-align: center;
			}
			img {
				display: block;
				background: white;
				border: 1px solid #ccc;
				margin: 0 auto;
			}
			figcaption {
				font-size: 14px;
				margin: 1em 0;
			}
			nav, hr, h1, h2, h3, h4, h5, h6 {
				clear: both;
			}
		</style>
	</head>
	<body>
		<nav>
			<div>
				<a href="../../index.html">Home</a><a href="index.html">Up</a><a href="values.html" class="mdsite-prev-link">Prev</a>
			</div>
			<div>
				<a href="effects.html" class="mdsite-next-link">Next</a>
			</div>
		</nav>
		<hr/>

		<article>
			<h1 id="what-is-a-process">What is a Process?</h1>
<p>In this book, I use the word <em>process</em> to mean &quot;a sequence of changes to some part of the world&quot;. We&#39;ll call the part of the world that a process changes the <em>state</em> of the process. Each change, or <em>step</em>, enacted by a process takes the current state and transforms it—often just a tiny bit—to get to the next state in the sequence. Though each change may be small, a long sequence of such changes can produce intricate structures or perform complex calculations.</p>
<p>Processes are interesting and useful because they give us a way to carry out very complex tasks with limited computational or mental resources. The machinery that performs each step tends to be restricted in some dimension: perhaps it has limited built-in memory, or a limited amount of time to perform each step. Perhaps the machinery is divided up into many parts that each act on a corresponding part of the state, and can only communicate with each other in limited ways. By recording information in the state for later use, the machinery is enabled to do its job.</p>
<p>Processes are everywhere. One everyday example of a process is pen and paper arithmetic. Most of us don&#39;t have the mental machinery to be able to multiply two ten-digit numbers in our heads, but by writing down the problem and performing a series of mechanical <em>steps</em> on that written <em>state</em>, we can reliably solve such problems.</p>
<p>Another example of a process is baking bread. When kneading dough, in particular, there is feedback from the dough to the baker; the process of kneading cannot be done insensitively if you want the result to be good. You need to assess the texture of the dough at every step, and continue adding flour just until the texture is right.</p>
<p>In both of these examples, note the key fact that the current state of the process informs the next step. This idea—that the state feeds back into the development of the process—is common to all processes.</p>
<h2 id="software-processes">Software Processes</h2>
<p>A software process is the running instantiation of a program. Programs are static data: bytes of code written to a file. Processes, by contrast, are dynamic, mercurial; real and yet intangible. In the same way that sheet music comes to life when an orchestra performs it, a program comes to life by directing the movements of a process.</p>
<pre><code>   program     : computer  : process
:: sheet music : orchestra : concert
</code></pre>
<p>On a macOS or Linux system, you can list the currently running processes by running <code>ps aux</code> at a terminal. A new process is created every time you run a program. For example, if you run <code>node</code> to start a JavaScript REPL, that creates a process. A single program can give rise to multiple concurrent processes. For example, if you open multiple terminal windows, you can run <code>node</code> in each one. The program <code>node</code> is unaffected by this; it remains, unchanging, on disk. The several <em>processes</em> instantiated from the program are identified (by the operating system) by different process IDs (PIDs), each associated with an independent <em>state</em>. The operating system arranges things so that each process&#39;s state evolves according to the rules of its program. (Note: this model of how processes work is extremely simplified, but it is adequate for the purposes of writing JavaScript.)</p>
<p>One way to understand code is to &quot;simulate&quot;, in our heads, the process it produces. I put &quot;simulate&quot; in quotes because this &quot;simulation&quot; <em>is</em> a real computational process. A mental process can perform useful computational work just as a silicon-based one can, as we can see in the following example:</p>
<pre><code class="language-js">const plain  = &quot;abcdefghijklmnopqrstuvwxyz&quot;
const cipher = &quot;nopqrstuvwxyzabcdefghijklm&quot;

function caesarCipher(s) {
  let result = &quot;&quot;
  for (const char of s) {
    result += cipher[plain.indexOf(char)] ?? char
  }
  return result
}

let deciphered = caesarCipher(&quot;terng junyr&quot;)
</code></pre>
<p>If you can simulate in your head (or on paper) the process of running this code, you will obtain the knowledge of what the ciphertext <code>&quot;terng junyr&quot;</code> means, just as well as if you had run the program on a computer. The mental process is <em>equivalent</em> to the computerized one—though it is quite a bit less efficient.</p>
<p>This is not true for every program, however. Consider this one:</p>
<pre><code class="language-js">function showDate() {
  document.write(new Date())
}

showDate()
</code></pre>
<p>The purpose of this program is to display the current date and time on an HTML page. We can only simulate this process in our heads at a very abstract level, by imagining potential times that it might display and what they would look like on a computer screen. Whereas the mental process for the <code>caesarCipher</code> function could proceed very concretely, and produce actual knowledge, our mental process for <code>showDate</code> cannot produce the knowledge or the effect that the program would produce when run on a computer. That is, we can&#39;t pluck knowledge of the current time out of thin air, nor can we telekinetically project text into our web browser. Thus, the process of mentally simulating this program is fundamentally incommensurate with the process produced by running it on a computer.</p>
<p>It seems that there are two types of processes:</p>
<ol>
<li>Those that can produce their intended result when carried out mentally.</li>
<li>Those that can&#39;t.</li>
</ol>
<p>What causes a process to belong to one or the other of these categories? Processes of the first type deal only with <em>symbol manipulation</em>, while processes of the second type need computer <em>hardware</em> to do their job. For example, the <code>showDate</code> program is only useful if our computer has a display and an internal clock.</p>
<p>I will call proceses of the first type (and their corresponding programs) <em>symbolic</em>, and processes and programs of the second type <em>effectful</em>.</p>
<!--

The processes listed by `ps aux` are what I'll call _operating system processes_; the abstract idea of a _software process_ is more general. Operating system processes are _Turing complete_, so an OS process can simulate any number of other processes—it can even simulate a whole operating system! We can think of `node` as being just such a process simulator. `node` processes can perform any number of tasks, from serving web requests to compiling TypeScript, by reading in the source code of a JavaScript program and then "simulating" the evolution of a process instantiated from that program. I put "simulating" in quotes because these "simulated" processes can do quite real and useful work!

We can go one level further, and create our own simulated processes within a JavaScript process. The mechanism JavaScript provides for this is _generator functions_. Here is an example of a generator function:

```js
function *greetForever() {
  let n = 0
  while (true) {
    console.log("Hello, world " + n + "!")
    n++
    yield
  }
}
```

The `*` before the function name makes `greetForever` a generator function. If we call `greetForever`, it does not enter an infinite loop, but simply returns a process-like object that JavaScript calls a `Generator`.

```js
const process = greetForever()
```

How do we actually run this process? We can call the `next()` method on it:

```js
process.next()
```

This causes the generator function to run until execution reaches a `yield` statement. Once a `yield` statement is reached, the process pauses execution, and the call to `next()` returns.

The visible effect of calling `process.next()` is that it logs `Hello, world 0!`. Internally, it also increments the `n` variable (part of the process's _state_). If we call `next()` again, it will log `Hello, world 1!`, and so on.

There is more to learn about generator functions in JavaScript, but it can wait for future chapters.

## Deterministic Processes

## Process to Processes

The title of this book, _Process to Processes_, refers to the twin facts that 1) all software is developed by some kind of _process_, and 2) the ultimate result of software development is a set of running _processes_ on one or more computers. Processes are the beginning and the end of software development, and they often show up in the middle, too. I will refer to the first type of process as a _development process_, and to the second type of process as a _software process_.

<!--
But what exactly *is* a process? We have an intuitive notion of what a *development process* is, abstracted from examples like Scrum, Extreme Programming, and Waterfall. A development process tells you what steps to follow to make software. We also use the word "process" to mean the running instantiation of a _program_. We can list the running *processes* on a macOS or Linux computer using the `ps aux` command. Is there some notion of a process that is general enough to cover both of these senses of the word? I think there is.

## Definition of "Process"

A process is a sequence of _states_, defined by an initial state, S<sub>0</sub>, and an _algorithm_ that obtains the (n+1)<sup>th</sup> state, S<sub>n+1</sub>, from the n<sup>th</sup> state, S<sub>n</sub>. You can think of each state as a bundle of information—or, if you like, as a data structure. The sequence of states in a process is potentially infinite.

Let's first look at how this definition applies to software processes. Suppose we have the following JavaScript program:

```js
let i = 1;
while (i < 10) {
  i++;
}
```

There is one variable in this program, `i`, so we can model the state of the process it generates as a data structure holding a number and some indication of which line of the program will be executed next. Something like this (TypeScript):

```ts
type State = {i?: number, nextLine: number}
```

When our program starts running, the initial state is (conceptually):

```js
state = {i: undefined, nextLine: 1}
```

The first line of the program sets `i` to `1`. After that line executes, our state is:

```js
state = {i: 1, nextLine: 2}
```

The second line of the program checks whether `i` is less than `10`, continuing at line 3 if so and at line 4 if not. In this case, `i` *is* less than `10`, so we go to line 3. The next state is:

```js
state = {i: 1, nextLine: 3}
```

Line 3 increments `i` and loops back to line 2.

```js
state = {i: 2, nextLine: 2}
```

On line 2, we perform the check again; `i` is still less than 10, so we go back to line 3.

```js
state = {i: 2, nextLine: 3}
```

The state keeps evolving as we go around and around the loop. Eventually, `i` reaches 10. Here's what the state looks like immediately after `i` is incremented to 10 on line 3:

```js
state = {i: 10, nextLine: 2}
```

Back on line 2, the `i < 10` comparison evaluates to `false`. We go to line 4.

```js
state = {i: 10, nextLine: 4}
```

Line 4 is the end of the program, so each subsequent state in the process will be the same as the current one. Our process has *halted*.

This precise definition of a process isn't a perfect fit for either *software processes* or *software development processes*, though the nature of the misfit is different in each case.

The definition doesn't perfectly apply to software processes because the state of a software process can be changed by an intervention from outside the process (e.g. an _interrupt_, or the result of a _system call_). So the process's algorithm doesn't fully determine the sequence of states.

-->
		</article>

		<hr/>
		<nav>
			<div>
				<a href="../../index.html">Home</a><a href="index.html">Up</a><a href="values.html" class="mdsite-prev-link">Prev</a>
			</div>
			<div>
				<a href="effects.html" class="mdsite-next-link">Next</a>
			</div>
		</nav>
		<script>
document.onkeydown = (e) => {
	switch (e.key) {
		case "ArrowRight":
		  document.querySelector(".mdsite-next-link")?.click()
			break;
		case "ArrowLeft":
			document.querySelector(".mdsite-prev-link")?.click()
			break;
	}
}

		</script>
	</body>
</html>
