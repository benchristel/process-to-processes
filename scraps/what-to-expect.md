# What to Expect From This Book

## Part I: Programming

After reading Part I of this book, you will be well equipped to understand the rest of the literature on software design and testing. You will have clear, useful definitions for common but often vaguely-defined terms like "object-oriented programming", "unit test", and "dependency". You'll also learn some extremely useful concepts that aren't widely talked about, like _processes_, _effects_, and _general-purpose code_. You'll be able to use these concepts to think and communicate about your programs with unprecedented ease and clarity.

Once you've spent some time practicing the techniques in this part of the book, you will be able to quickly develop programs that have very few bugs. Moreover, you'll achieve this without spending much time at all debugging. In the rare but inevitable event that a bug is reported in your code, you'll immediately know why it's happening, and you'll be able to fix it in a matter of minutes.

You will be able to explain to other programmers on your team why you make the technical decisions you do, and how those decisions lead to good outcomes for programmers and users alike. If you are well-liked by the other members of your team, you may find yourself with significant influence over its technical culture.

Your track record of reliably delivering high-quality software will make you a trusted ally of the non-technical members of your organization. When you tell them that a proposed design will take too long to implement, they'll believe you, and listen to your counter-proposal. When you suggest improvements to the software that will cost next to nothing to implement, they'll be delighted. By negotiating small adjustments to the scope and sequencing of changes, you'll be able to create useful, valuable software at low cost.

## Part II: Working With Others

Part I covered the details of making software that works. Its guidance applies whether you're working alone or with other people. Part II is about the dynamics of working on a team.

After reading Part II, you'll be able to identify the friction points that are slowing your team down. You'll also be equipped with a suite of techniques for removing that friction. Your entire team will become more effective as a result of applying these techniques.

## Part III: User Interfaces

In part III, you'll learn principles for designing interfaces—for both programmers and end-users—that let people accomplish their goals with minimal effort and uncertainty. By applying these principles in conjuction with user research and interviews, you'll be able to arrive at good designs much more quickly.

## Part IV: The Tao of Software Development

The preceding parts convey many disparate ideas and techniques; Part IV ties them all together.
