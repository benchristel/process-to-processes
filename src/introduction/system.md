# The System

There is a system of interacting people and computers that creates value for your employer. As a software engineer, your job is to improve this sociotechnical system so it nets more value.

Improving the system might mean writing code, but it might also mean:

- Reporting a bug
- Learning a new skill
- Teaching that new skill to someone else
- Rethinking how your team prioritizes and assigns tasks
- Studying the business domain you're working in
- Setting up a recurring meeting
- Canceling a meeting that's no longer useful

Your organization _is_ software, albeit software that runs on people instead of silicon. Its code is the policies, incentives, habits, and communication pathways that shape its employees' behavior. If no one engineers that system to work well, then—surprise surprise—it will work poorly.

## An Example of a Healthy System

I was lucky enough to spend five years working at Pivotal, a company whose "peopleware" was designed by an excellent software engineer, Rob Mee. I'm still in the process of analyzing that design and figuring out how it worked, and all the tradeoffs it made—but for us, it worked astonishingly well.

Some facts about that system:

- Each team was co-located in an office.
- We all worked the same hours: 9 to 6 with a one-hour lunch break at 12:30.
- We pair-programmed full time.
- We didn't have laptops. There was no way to take work home.
- We barely looked at email, or any other digital communication platform. All communication was in-person.
- We had about two hours of whole-team meetings per week: a one-hour planning meeting on Monday, and a one-hour retrospective on Friday.
- We got catered breakfast every day. The snacks were free. We took frequent ping-pong breaks.

This way of working might sound strange to you—that's kind of the point. Take it as an illustration of some of the ways a system can differ from your own.

## What Can You Change?

As an individual engineer working for a large company, you're not, of course, going to be able to make changes this radical yourself. What you _can_ do is choose how to set the various knobs and levers available to you. You can choose, for instance, to do more synchronous communication, or more asynchronous communication.

## Systems Are Grown, Not Made

Because money is limited and the future is uncertain, the system cannot be created, all at once. It must be _grown_, bit by bit, incorporating [feedback](feedback.html) from its environment at every step. A system that is designed and built all at once is almost certain to be as dead as a flower made from glued-together petals and leaves.

## Implications

The idea that a software engineer's job is to improve the system has some often-overlooked implications.

- Because money is limited and the future is uncertain, the system cannot be created, all at once. It must be _grown_, bit by bit.
- Improving the system involves reshaping both human-computer *and* human-human interactions.
- Code, viewed as instructions for a computer, is a) very cheap, and b) a poor proxy for value.
- A better proxy for value is the "intelligence" of the whole system: its ability to act effectively and to learn. Your own skills and learning abilities contribute to this, but the smartest organizations are smarter than the sum of their members.

## But I Work Alone!

You might not be part of a larger organization. You might be a team of one. In that case, your task is simpler and your system-fu need not be as strong. But it's still needed in some measure. You won't have to manage interactions among different people, but you _will_ need to manage communication between your past, present, and future selves. Good software design, a well-organized backlog or TODO list, and a tidy commit log will all contribute to this.