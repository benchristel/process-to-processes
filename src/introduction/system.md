# The System

There is a system of interacting people and computers that creates value for your employer. As a software engineer, your job is to improve this sociotechnical system so it nets more value.

Improving the system might mean writing code, but it might also mean:

- Reporting a bug
- Learning a new skill
- Teaching that new skill to someone else
- Rethinking how your team prioritizes and assigns tasks
- Studying the business domain you're working in
- Setting up a recurring meeting
- Canceling a meeting that's no longer useful

Your organization _is_ software, albeit software that runs on people instead of silicon. Its code is the policies, incentives, habits, and communication pathways that shape its employees' behavior. If no one engineers that system to work well, then—surprise surprise—it will work poorly.

## An Example of a Healthy System

I was lucky enough to spend five years working at Pivotal, a company whose "peopleware" was designed by an excellent software engineer, Rob Mee. I'm still in the process of analyzing that design and figuring out how it worked, and all the tradeoffs it made—but for us, it worked astonishingly well.

Some facts about that company:

- The company had about 3000 employees, spread over a dozen-plus offices worldwide.
- Each team was co-located in an office.
- We all worked the same hours: 9 to 6 with a one-hour lunch break at 12:30.
- We pair-programmed full time.
- We didn't have laptops. There was no way to take work home.
- We barely looked at email, or any other messaging app. All ephemeral communication was in-person.
- We had about two hours of whole-team meetings per week: a one-hour planning meeting on Monday, and a one-hour retrospective on Friday. No other standing meetings.
- Managers spent about 80% of their time writing code. Your manager probably wasn't on your team, and wasn't necessarily the lead engineer on _their_ team.
- We got catered breakfast every day. The snacks were free. We took frequent ping-pong breaks.

Much of this probably sounds very different from your current way of working, perhaps alarmingly so—and that's kind of my point. Take this as an illustration of some of the ways a system can differ from your own.

I'm *not* saying you have to work this way. I'm saying you should feel free to change things up, even in wild-seeming ways, as long as the resulting system works for you and your context. The landscape of possibility is much wider than what current "industry-standard practices" would have you believe.

## What Can You Change?

As an individual engineer working for a large company, you're not, of course, going to be able to make radical changes on your own. What you _can_ do is choose how to set the various knobs and levers available to you. You can choose, for instance, to do more synchronous communication, or more asynchronous communication.

## Systems Are Grown, Not Made

It's tempting to try to design the perfect system up front, put all the pieces together, and let 'er rip. That approach is pretty much doomed to fail.

> A complex system designed from scratch never works and cannot be made to work. You have to start over, beginning with a working simple system.
>
> —John Gall, [_Systemantics_](https://en.wikipedia.org/wiki/Systemantics), p. 71

Because money is limited and the future is uncertain, the system cannot be created, all at once. It must be _grown_, bit by bit, incorporating [feedback](feedback.html) from its environment at every step. A system that is designed and built all at once is almost certain to be as dead as a flower made from glued-together petals and leaves.

## Implications

The idea that a software engineer's job is to improve the system has some often-overlooked implications.

- Because money is limited and the future is uncertain, the system cannot be created, all at once. It must be _grown_, bit by bit.
- Improving the system involves reshaping both human-computer *and* human-human interactions.
- Code, viewed as instructions for a computer, is a) very cheap, and b) a poor proxy for value.
- A better proxy for value is the "intelligence" of the whole system: its ability to act effectively and to learn. Your own skills and learning abilities contribute to this, but the smartest organizations are smarter than the sum of their members.

## But I Work Alone!

You might not be part of a larger organization. You might be a team of one. In that case, your task is simpler and your system-fu need not be as strong. But it's still needed in some measure. You won't have to manage interactions among different people, but you _will_ need to manage communication between your past, present, and future selves. Good software design, a well-organized backlog or TODO list, and a tidy commit log will all contribute to this.