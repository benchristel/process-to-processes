# About This Book

My colleagues sometimes ask me if there's _one book_ I'd recommend that teaches "the stuff you need to know to be a senior engineer". I haven't been able to pick just one... until now!

This book teaches the concepts and techniques that I consider essential for application programmers working in a modern organization, circa 2023. Not all of these topics are widely discussed in the popular discourse. Some, like _general-purpose code_ and _shallow hierarchies_ (TODO links) are right under our noses, yet hardly ever mentioned. Others, like _test-driven development_ and _static typing_, are misunderstood in the industry at large, but can give you incredible leverage if you grok their essence. I try to cut through hype and misconceptions, frankly acknowledging the strengths and flaws of each idea I present.

There are, of course, many topics in software development that are best learned on the job. This book tries to cover everything else. The topics in this book fall into a few categories:

- Stuff your coworkers probably _won't_ teach you—perhaps because it seems nitpicky or pedantic to point it out, or because it's entangled with so many other concepts that they're not sure where to begin.
- Stuff your coworkers probably _can't_ teach you, because they never learned it themselves. Test-driven development and type-driven design are likely to fall into this category.

Reading this book will give you new ways of looking at your programs. You'll learn to head off many potential problems before they impact production. You'll be able to explain to your teammates why you make the technical choices you do. And you will gain—and this is perhaps the most important thing—you will gain a deep and abiding sense of connection to your work, and to the scientific and technological community out of which our discipline has grown.

Unlike many other resources on software design, this book avoids moralizing. I reject the idea that buggy software, poor-quality code, etc. are due to programmers' moral failings, immaturity, or stubbornness. I believe that most people want to do the right thing—though the rightest thing they know how to do may still be ineffective. I've seen firsthand that even a team with the best of intentions can produce a bug-ridden mess that has to be thrown away after a year of development. I've _been_ the programmer who writes the bug-ridden mess. I've also been the programmer who [goes back to that mess five years later and fixes it](https://github.com/gavmor/dunmanifestin/compare/3dd7afc9f582ad86e5f3828784a75375b81b56b2...431c1c2f7dbdfbe6833f6654ec4abdc6d8703212). The problems in our industry are due to lack of skill, not lack of will—which I think is an optimistic take, because skills can be learned.

This book is divided into four parts.

- _**Part I: Programming**_ is about, well, programming—which in my book includes software design, testing, architecture, documentation—the whole shebang. _Programming_ is the first part of the book because it's the foundation of everything we do. Our job, ultimately, boils down to getting computers to do what we want in a way that doesn't cost a fortune. Although software design is, [as Kent Beck points out](https://tidyfirst.substack.com/p/coming-soon), an exercise in human relationships, relationships are founded on trust. Programmers earn trust by quickly and reliably delivering working software.
- _**Part II: Working With Others**_ explores how to maintain and build human relationships around software once the initial level of trust is earned. It describes communication patterns and team dynamics that are good for the whole system—people _and_ code, employees _and_ customers.
- _**Part III: User Interfaces**_ discusses the principles behind user interface design. There is a shortage of UI and UX designers in the software industry of 2023, and programmers are often called upon to make design decisions. This part of the book tries to ensure that the designs we produce will be comfortable and straightforward to use for the people who have to use them.
- _**Part IV: The Tao of Software Development**_ goes back to the original software consultant's manual, the _Dào Dé Jīng_, or "Book of the Way and Virtue", written 2500 years ago in China by an unknown author. While the details of software have changed much in the last two millennia, people have stayed approximately the same, so there is plenty of applicable wisdom in this venerable text. In this part of the book, we'll see that even the humblest aspects of programming contain profound insights into the nature of our universe and ourselves. The practical and the mystical will be fused, as if by lightning.

## Note on Technologies

With few exceptions, I avoid discussing specific technologies in this book. There are a couple reasons for that. One is that over-reliance on any specific technology (say, React, or Jest, or Ruby on Rails) would limit the audience for this book, which would be a shame because the book contains many concepts that apply across technologies. A second reason is that technologies evolve and get replaced, so books about them tend to go stale quickly. In writing, as in programming, I prefer to avoid dependencies on specific technologies, when I can.

But there is a more fundamental reason for avoiding discussion of specific technologies: they just aren't that important for your overall career. A generalist programmer—someone who's familiar with the various shapes languages and tools can take—can become productive in a new language or framework in a matter of weeks.  Furthermore, your coworkers can almost certainly teach you the tech your company uses—and the specific _ways_ they use that technology—with much higher fidelity than a book ever could.

The exception is "foundational" technologies, like Unix, `git`, SQL databases, and (probably) your programming language of choice. It's worth spending the time to master these. They change slowly, so your knowledge will pay dividends for a long time, and in any case they're so ubiquitous that it's hard to avoid depending on them. Since foundational technologies are widely used, they tend to be rock-solid stable. Maintaining this stability demands a level of engineering rigor that is worth studying for its own sake. I point out many of these foundational technologies in the book, but I don't dive deep. Their documentation is easy enough to find.

There's one technology dependency I couldn't avoid—the programming language I use for code examples. For that, I chose TypeScript. TypeScript is a superset of JavaScript that introduces a static type system. Because JavaScript is a multi-paradigm language that can run on both client and server, and because TypeScript enables but does not require static type safety, TypeScript is an ideal vehicle for comparing different approaches to programming. TypeScript also happens to be rapidly growing in popularity as of this writing—though it hasn't yet overtaken JavaScript, which has maintained its position as the most widely-used language (according to [polls of StackOverflow users](https://insights.stackoverflow.com/survey/2020#most-popular-technologies)) for the last decade.

## About the Author

I started programming in 1998. Since then, I've worked on many different projects in a variety of languages, including JavaScript, TypeScript, Go, Ruby, Java, C, Bash, and Visual Basic. I have more than a decade of industry experience, and have worked professionally on over a dozen teams, building everything from point-of-sale systems to social networks and ed-tech apps. I've also worked on many, many side projects, sometimes on my own, and sometimes with a friend. All told, I've spent about 30,000 hours programming, and just about every hour has taught me something new.
