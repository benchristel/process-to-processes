# Principle: Adaptation

A.K.A. The whole system grows together - people, software, tools. The software becomes adapted to the tools used to make it. The tools adapt to the software. The people in the system adapt the software and the tools to work for them.

Adaptation is essential for efficient work. When a tool isn't adapted to the job people need it to do, it will be used less and misused. In extreme cases, the tool might not get used at all, becoming _shelfware_. Poorly adapted software systems create drag and dead weight for an organization.

On the other hand, when we have well-adapted tools and processes, our jobs become efficient and pleasant.

But there's more to adaptation than simple efficiency. Adaptation gives people a sense that the system they're in supports their needs, and in some way deeply _understands_ them. The psychological benefits of this are hard to understate. Adaptation is the antidote to {{link Alienation}}, which spells death for motivation and creativity.

The term "Adaptation" for this idea comes from Christopher Alexander: https://www.youtube.com/watch?v=o6q1dDAv6zY

Examples of adaptation in software:

- One advantage of object oriented idioms is that the dot method syntax enables ergonomic autocomplete in IDEs. (see: Brian Will)
- Anecdote about prefixes for member variables in C++
- algebraic types enable data to be manipulated directly / coupled to lots of code without creating massive headaches
- TDD expands the horizon of problems you consider hard, lets you consider more solution paths
