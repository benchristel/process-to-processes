# View: The Life and Death of Systems

- Systems can be stable (self-sustaining) or unstable (prone to collapse or replacement)
    - Caveat: instability of the parts sometimes contributes to stability of the whole!
      - Examples: economics (competition means firms that can't compete go out of business, but the market is more efficient), evolution (because individuals die, the species can survive and adapt in a changing environment)

Being stuck in a dying system is no fun!

dying systems can be kept on life support by an influx of money, or heroic feats.

living systems can be killed by the clumsiness or malice of some larger system.

## Software Gardening

A healthy system is like a healthy garden: it produces lots of value, sustainably. When a system becomes unhealthy
it produces less value, and may even start to die. An unhealthy system needs to be propped up by expensive interventions (think pesticides and fertilizers) just to keep going.

Our primary goal in software development must be to create a healthy system. Otherwise, we will be forever overpaying for underwhelming results.

## Technique: Relative Life as a Design Heuristic

- The rational part of your brain is slow, expensive, and weak. ({{link SoftwareDevelopment/Humans.html "Humans, Not Humanoids"}})
- Our hardware is optimized for holistic perception and feeling.
- Perhaps you have had the experience of lying awake at night tossing and turning because you can't get comfortable. You may have discovered that _trying_ to be comfortable, and overthinking it, is part of the problem. It's nearly impossible to find a comfortable position by planning it out. The only way to get to sleep is to forget control completely, and let your more efficient instincts take over.
- In exactly the same way, it is nearly impossible to design a living system by reasoning out all the interactions between forces. It is much easier to get wholeness by feeling your way to it, letting the forces themselves drive your behavior until they work themselves out.
- Compare: _Notes on the Synthesis of Form_ to _The Nature of Order_.
- Therefore, **our judgment of relative life must be our central guiding criterion as we design**. There is no other way to get quality/value at a reasonable speed.
- ...but we also have to confirm that our snap judgments are reasonable, e.g. by asking "who benefits"?
- When we can be honest with ourselves about which of two situations feels more alive or dead, the difference is often immediately obvious. Although a feeling of relative aliveness is no guarantee that a solution is good, and needs confirmation from rational processes, a feeling of relative deadness is a good enough reason to reject a solution.
- We can also automate a lot of judgments about the software components of the system, e.g. with tests, types, and linters.

## The Feeling of Deathly Morphology

alienation - "feeling like a cog in a machine"

the world "alien" comes from the Latin _alius_, meaning "other". An alienating system is one that makes you feel like an outsider. _Keep out_ you can almost hear it saying. _You do not belong here. You are only a visitor. Do not question the order of things._

- "Apparently it wants me to do X? I'm not sure why, but I'll do it."
- "Ugh, why is this so hard?"

alienation leads to a loss of agency, and disengagement. Alienated workers stop thinking and stop caring. They become emotionally uninvested in the results of their work. They try to get work off their plate and make it someone else's problem as quickly as possible.

To counter alienation - use {{link SharedOwnership}} (facilitated by {{link PairProgramming}}). Early in their life, alienating systems are often {{link KnowledgeSilo}}s where one person is the keeper of the keys. But when that person leaves the company or moves on to other projects, the system can keep going with _no one_ who really understands it or feels ownership of it. Such a system will keep on causing suffering until it dies. 

implications for both team work and software UX design
