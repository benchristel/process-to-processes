Messages are the means of passing [[Control]] in an [[ObjectOriented|ObjectOrientedProgramming]] system. [[Object]]s communicate by sending messages. When code in one object sends a message to another object, control passes to the second object, which must then figure out how to process the message.

Typically, [[ObjectOrientedProgramming]] languages have special syntax for defining [UnitsOfCode](UnitOfCode) that handle specific messagesâ€”these handlers being traditionally referred to as [[Methods]] (though note that my definition of a [[Method]] is slightly broader). However, it's possible to do OO without special method syntax, as [[AnjanaVakil]] demonstrates (TODO link to talk)

Strictly speaking, messages are [[Value]]s, though object-oriented languages like Java and Ruby lack first-class values and represent messages as [[Object]] references. The problem with using objects as messages is that it breaks encapsulation, defeating the object-oriented principle that objects may only communicate by message-passing. As an example of the problem: if two objects A and B are communicating, A may send a reference to a third object C to B. Since both A and B then have a reference to C, B might communicate back to A by changing C's [[State]]. Another thing to note is that implementing literally _all_ messages as objects leads to an absurd infinite regress: if messages are objects, then the only way to extract information from a message is to send a message, meaning that every message received causes at least one other message to be sent.

An open question I need to explore: if all messages are values, how does the object graph get built? It seems like sometimes you want an object to be shared (e.g. the [[ObserverPattern]] and [[VisitorPattern]]).