# Goals

Some people love gardening, some love cooking, some love improving and decorating their homes, some love tinkering with their cars or bikes, and some—a few—love working with computers.

Houses, land, food, cars, and computers are all necessary parts of modern life. Loving them is optional; interacting with them is not. That is to say, many people who are _affected_ by these artifacts are not emotionally _involved_ in their creation. For some people, a house is just a box that you live in, a yard is just the land the house sits on, food is just nutrition, a car is just a way to get from A to B, and a computer is just a portal to most other necessary evils. It takes time and energy to be emotionally involved in an activity—even something you do every day—so most people just choose one or two hobbies.

There is an emotional cost, though, to _having_ to interact with something that you do not love; that is, to being _affected_ without being _involved_. It tends to be alienating, intimidating, and frustrating. This is _especially_ true of interactions with computers. Things don't work and you don't know why. Then, sometimes, they _do_ work, and you still don't know why. You feel like the computer is gaslighting you. You pay other people to make the problem go away, and sometimes, it goes away.

The more we try to push the computer away, to hide its terrifying blossoming complexity, the worse it gets. Every layer of indirection and abstraction brings with it the possibility of new failure modes. And yet to do the opposite—to hold the computer close, and try to understand it—is intolerable. It is intolerable, because the superficial face of the computer is vapid, commercialized, patronizing, pretentious, banal, and manipulative. It has all the aesthetic grace and gravitas of a highway billboard.

There is a positive feedback loop here, from complexity to superficiality and commercialization and back again. When individual computer users don't understand computers, corporations and governments have more power to manipulate them. The more manipulative corporations and governments get, the less attractive computers seem, and the less anyone wants to understand them.

---

I want people to feel connected to the world around them, and to be able to shape their lives and surroundings in a way that
suits them. I want people to realize that they have "eyes and hands"—the ability to understand what's going on, and to grasp and manipulate the materials of which their world is made. As a software practitioner, I'm _specifically_ concerned with doing this in the digital realm. Moreover, I believe that the first step has to be, not to get end users more emotionally involved with computers, but to get *people working in the software trade* more emotionally involved. If the people making the software do not love it, then it has no chance of ever being loved.

If you are a programmer, I want you to try to imagine what it would take to create software that someone could truly love. Software that inspires affection, software to which one feels akin. What could inspire someone to love a computer, or a program, in the way that one can love a beautiful cozy house, a sunny spot in the garden, or the shade of a forest?

I know what my mother would say: "I know _you_ like computers a lot, Ben, but for most people, a computer is just a tool."

Yes, and:

A house is just a box.

A garden is just land.

Food is just nutrition.

A car is just transportation.

I don't think every person has to love computers. But I want them to _be able to_. Right now, they can't. _There isn't anything lovable there_.

What would it take to create software that someone could truly love?

---

> Physician, heal thyself!

The solution starts with us: software practitioners. Programmers, designers, product managers.

## What I Think Is Needed

- technical expertise - we have to be able to execute flawlessly
- democratization - more people should be able to make their own software
- free and open source software - we need high-quality, non-commercial solutions to common problems
- better UX design
- stability: you should be able to run the same software forever without major upgrades
  - platforms must ensure backwards compatibility
    - Linux and the Web are the model here
  - open source (so you can build old software for new architectures)