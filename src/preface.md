# Preface

**Empirical Software Development** is a way of working where action naturally flows from information. You see a problem or an opportunity. You figure out what to do about it. You do it. You check that it worked.

(arrow diagram: information -> action -> results -> feedback -> information)

It sounds simple, but of course it isn't easy. In real organizations, the diagram often looks more like this:

(arrow diagram: info -> triage -> miscommunication -> indecisiveness -> delays -> red tape -> action -> results? - - - > feedback? - - - > info; {politics, ego, fear} -> action)

ESD gives you a recipe for gradually untangling this kind of organizational dysfunction. It starts by pulling at a loose endâ€”the fingers-on-the keyboard act of typing code. Then it works in larger and larger loops, broadening the perspective to software architecture, team dynamics, user interfaces, and finally the organization as a whole.

Grand schemes aside: at the individual, personal level, we have to grapple with questions like:

- What if I don't have all the information?
- What if I have a hunch, but can't prove it?
- What if I have the information, but don't know what to do about it?
- What if I make the wrong decision?
- What if my coworkers disagree with me?
- What if I don't have the time or the know-how to "do it right"?

The fear underlying all of these questions stems from an illusion: the illusion that someone else has all the answers, and the rest of us are just doofuses stumbling around in the dark. In reality, no one has all the answers. The best anyone can do is, as Maya Angelou put it, to "do the best you can until you know better. Then when you know better, do better." That is the heart of Empirical Software Development.

## Empirical Software Development Skills

Good intentions are noble, but they aren't worth much unless backed up by expertise. Practitioners of Empirical Software Development are constantly honing their skills. Their technical skills include:

- Mastery of their chosen programming language
- Familiarity with several different languages
- Test-driven development
- Refactoring
- Software design
- User experience design

Perhaps the most important ESD skills, however, are those you can apply outside software development. These include:

- Clear, kind communication
- Focusing on one thing at a time
- Broadening your awareness to synthesize information from disparate areas
- Systems thinking

This book will teach you these skills, and more.

## Empirical Software Development Values

Empirical Software Development probably isn't right for every team or project. You'll get the most out of it if you value certain things:

- **Defect-free software** over lots and lots of features
- **Steady improvement** over chasing utopian ideals
- **Being genuine** over looking impressive
- **Being kind** over being cute

Of course, my biases should be readily apparent from the above list. Salt to taste.

## What Empirical Software Development Isn't

As I write this description of ESD, I'm already worrying about how people might misinterpret it in the future. How very un-empirical of me, to worry without evidence. Well, now you know I'm not perfect, either.

Empirical Software Development:

- does NOT mean that quantitative data is the only information that matters
- does NOT mean that programmers have to or get to make all the decisions
- is NOT the One True Way to program.

## Comparison to Empirical Software Design

Kent Beck is currently working on a series of books about something he calls Empirical Software Design. I see a lot of overlap between this and Empirical Software Development, though they're not exactly the same idea. The similarity is almost certainly not a coincidence, because Empirical Software Development is based largely on Beck's earlier writing: Extreme Programming, Refactoring, Code Smells, and Test-Driven Development. Our ideas also share some deeper roots, in the design patterns movement and the works of architect-builder Christopher Alexander.

The difference I see between our versions of "ESD" is that Empirical Software Design focuses on refactoring, and improving the design of code based on your moment-to-moment experience. Empirical Software Development tries to apply a similar idea at the scale of an entire team, product, or company. The core idea, in both cases, is that a) you can always improve the system, and b) your experience of being in the system tells you what needs improving.