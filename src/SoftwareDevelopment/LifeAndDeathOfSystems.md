# View: Living Systems, Dying Systems

- Systems can be stable (self-sustaining) or unstable (prone to collapse or replacement)
    - Caveat: instability of the parts sometimes contributes to stability of the whole!
      - Examples: economics (competition means firms that can't compete go out of business, but the market is more efficient), evolution (because individuals die, the species can survive and adapt in a changing environment)

Being stuck in a dying system is no fun!

## Technique: Relative Life as a Design Heuristic

- The rational part of your brain is slow, expensive, and weak. ({{link SoftwareDevelopment/Humans.html "Humans, Not Humanoids"}})
- Our hardware is optimized for holistic perception and feeling.
- Perhaps you have had the experience of lying awake at night tossing and turning because you can't get comfortable. You may have discovered that _trying_ to be comfortable, and overthinking it, is part of the problem. It's nearly impossible to find a comfortable position by planning it out. The only way to get to sleep is to forget control completely, and let your more efficient instincts take over.
- In exactly the same way, it is nearly impossible to design a living system by reasoning out all the interactions between forces. It is much easier to get wholeness by feeling your way to it, letting the forces themselves drive your behavior until they work themselves out.
- Compare: _Notes on the Synthesis of Form_ to _The Nature of Order_.
- Therefore, **our judgment of relative life must be our central guiding criterion as we design**. There is no other way to get quality/value at a reasonable speed.
- ...but we also have to confirm that our snap judgments are reasonable, e.g. by asking "who benefits"?
- When we can be honest with ourselves about which of two situations feels more alive or dead, the difference is often immediately obvious. Although a feeling of relative aliveness is no guarantee that a solution is good, and needs confirmation from rational processes, a feeling of relative deadness is a good enough reason to reject a solution.
- We can also automate a lot of judgments about the software components of the system, e.g. with tests, types, and linters.
