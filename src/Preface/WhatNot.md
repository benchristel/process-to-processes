# What This Book Is Not

Receiving advice — especially advice about how to do our jobs, i.e. the work that sustains our existence — can feel like a threat. I know it does to me. Whenever I encounter a new expert opinion on software development, the hairs on my neck bristle as I brace myself to read it. _Are they going to say I'm doing it wrong?_

Therefore, I want to start by saying:

If you are shipping working code, you are not doing it wrong.

- _Something_ you're doing is working.
- Your feelings about your work are valid. <!--(In fact, as I will later argue, people's feelings are almost the only thing worth considering.)-->
- The things you'd like to improve about your work are worth improving, and maybe this book can help you with that.
- What I really want is for you to feel confident and satisfied writing great software. If something in this book doesn't help you do that, don't do it.

This book presents many ideas that are somewhat hyped-up and controversial: {{link FunctionalProgramming}}, {{link ObjectOrientedProgramming}}, {{link TestDrivenDevelopment}}, and {{link AlgebraicTypes}}, to name a few. However, I am not going to argue strenuously for any particular practice. Instead, I hope to show you how all these seemingly disparate pieces fit together into a kaleidoscopic yet coherent whole.

This unification seems to me to be long overdue. The more I read and listen to software development experts of the last 60-ish years, the more I am impressed by the deep similarities between their superficially different approaches. My goal with this book is not to present yet another theory of software development, but to show you how the good ideas already out there might, ultimately, just be different facets of what we knew all along.

<!--
## This Is Not A Software Development Method

The {{link Techniques}} in this book don't add up to a "methodology" (or even a method) for creating software. This isn't a step-by-step guide or a list of boxes to tick off. What I am trying to give you is:

1. A way of seeing your software, your team, and your company.
2. Ways of working that smoothly produce desirable outcomes within that picture of the world.

These two halves — which I call **views** and **techniques** — go together. The views are only valuable if you have the techniques to act on the information they give you. The techniques will only work if you can see what you're doing.

Although this book aims to be comprehensive, it can never have the final word. I have no grand unified theory of software development. I don't believe there can be one. All I have are enough different ways to look at software systems that I can build ad-hoc mental models of the *actual systems that are in front of me*, and that is enough. My goal is not to "solve" software development, but simply to create good software.

As you cautiously begin to try out my techniques, you might wonder "am I doing it right?" Stay cautious, but don't be anxious. If you're on the lookout for problems and ready to adjust, you're doing it right. Keep going. I have no doubt that with time, you'll improve on everything I've written here.

As you read through the chapters in this book—especially the {{link 36Views Views}} in first section, on {{link SoftwareDevelopment/index.html SoftwareDevelopment}}—you will probably have trouble piecing them together. It may be hard to see what I'm driving at. "What's the big picture?" you'll wonder. "What is his grand unified theory of software development?"

I have no grand theory. I don't believe there can be one. All I have are enough different ways to look at software systems that I can build ad-hoc mental models of the *actual systems that are in front of me*, and that is enough. My goal is not to "solve" software development, but simply to create good software. I don't need a grand unified theory for that.

Therefore, as you read the chapters, don't worry too much about fitting them together. Instead, try to relate each one to your own experience. The sooner you can get a feel for how my views and techniques play out in the real world, the sooner you will be able to apply them effectively.
-->