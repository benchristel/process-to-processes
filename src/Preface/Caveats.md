# Limitations and Warnings

## This Is Not A Software Development Method

The {{link Techniques}} in this book don't add up to a "methodology" (or even a method) for creating software. This isn't a step-by-step guide or a list of boxes to tick off. What I am trying to give you is:

1. A way of seeing your software, your team, and your company.
2. Ways of working that smoothly produce desirable outcomes within that picture of the world.

These two halves — which I call **views** and **techniques** — go together. The views are only valuable if you have the techniques to act on the information they give you. The techniques will only work if you can see what you're doing.

Although this book aims to be comprehensive, it can never have the final word. I have no grand unified theory of software development. I don't believe there can be one. All I have are enough different ways to look at software systems that I can build ad-hoc mental models of the *actual systems that are in front of me*, and that is enough. My goal is not to "solve" software development, but simply to create good software.

As you cautiously begin to try out my techniques, you might wonder "am I doing it right?" Stay cautious, but don't be anxious. If you're on the lookout for problems and ready to adjust, you're doing it right. Keep going. I have no doubt that with time, you'll improve on everything I've written here.

<!--

As you read through the chapters in this book—especially the {{link 36Views Views}} in first section, on {{link SoftwareDevelopment/index.html SoftwareDevelopment}}—you will probably have trouble piecing them together. It may be hard to see what I'm driving at. "What's the big picture?" you'll wonder. "What is his grand unified theory of software development?"

I have no grand theory. I don't believe there can be one. All I have are enough different ways to look at software systems that I can build ad-hoc mental models of the *actual systems that are in front of me*, and that is enough. My goal is not to "solve" software development, but simply to create good software. I don't need a grand unified theory for that.

Therefore, as you read the chapters, don't worry too much about fitting them together. Instead, try to relate each one to your own experience. The sooner you can get a feel for how my views and techniques play out in the real world, the sooner you will be able to apply them effectively.

-->